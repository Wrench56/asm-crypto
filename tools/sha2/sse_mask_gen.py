"""
SSE Mask generator for SHA256
"""

import os


def _generate_load_masks(n: int) -> list[list[int]]:
    """Return 4 SSE load masks with lanes enabled if they contain data"""
    masks = []
    for chunk_start in range(0, 64, 16):
        mask = []
        for lane in range(4):
            lane_start = chunk_start + lane * 4
            lane_end = lane_start + 4
            enabled = any(byte < n for byte in range(lane_start, lane_end))
            value = 0xFF if enabled else 0x00
            mask.extend([value] * 4)
        masks.append(mask)
    return masks


def _generate_term_shuffle_mask(n: int) -> list[int]:
    """Return a PSHUFB shuffle mask for the position of the terminator byte"""
    order = [i for i in range(1, 16)]
    order.insert(n, 0)
    return order


def _generate_blend_masks(n: int) -> list[list[int]]:
    """Generate 4 PBLENDVB masks (xmm3 to xmm6) for 0x80 and residuals"""
    insert_masks = []
    for chunk in range(4):
        base = chunk * 16
        mask = [0x00] * 16
        for i in range(16):
            abs_byte = base + i
            if abs_byte == n:
                mask[i] = 0xFF
            elif abs_byte > n:
                dword_start = abs_byte & ~0x3
                if dword_start < n:
                    mask[i] = 0xFF
        insert_masks.append(mask)
    return insert_masks


def main() -> None:
    """Main function"""

    table_path = '../../src/sha2/sha256_sse_mask_table.inc'
    size = 0

    with open(table_path, 'w', encoding='utf-8') as f:
        f.write('; ===== SSE MASK TABLE FOR PBLENDVB =====\n')
        f.write(f'; Generated by {os.path.basename(__file__)}\n')
        f.write('; DO NOT EDIT MANUALLY!\n\n')
        f.write('%define MASK_LENGTH 16\n')
        f.write('%define MASK_BLOCK_LENGTH 128\n\n')
        f.write('section .data\n\n')
        f.write('mask_table_begin:\n\n')

        for n in range(64):
            f.write(f'; === Masks for n = {n} ===\n')

            masks = _generate_load_masks(n)
            for xmm_index in range(3, 7):
                xmm_mask = masks[xmm_index - 3]
                f.write(f'mask_xmm{xmm_index}_n{n}:\n')
                for j in range(0, 16, 4):
                    bytes_h = ', '.join(f'0x{b:02X}' for b in xmm_mask[j:j+4])
                    f.write(f'    db {bytes_h}\n')
                    size += 4

            term_i_mask = _generate_term_shuffle_mask(n)
            f.write(f'term_shuffle_mask_n{n}:\n')
            for i in range(0, 16, 4):
                bytes_h = ', '.join(f'0x{b:02X}' for b in term_i_mask[i:i+4])
                f.write(f'    db {bytes_h}\n')
                size += 4

            insert_masks = _generate_blend_masks(n)
            for xmm_index in range(3, 7):
                xmm_mask = insert_masks[xmm_index - 3]
                f.write(f'blend_mask_xmm{xmm_index}_n{n}:\n')
                for j in range(0, 16, 4):
                    bytes_h = ', '.join(f'0x{b:02X}' for b in xmm_mask[j:j+4])
                    f.write(f'    db {bytes_h}\n')
                    size += 4

            # Add padding for easy offset calculation
            f.write('\ntimes 112 db 0x00\n\n')
            size += 112
        f.write('; END OF TABLE\n')
    print(f'Mask table generated: {table_path}')
    print(f'Mask table size     : {size} bytes')


if __name__ == '__main__':
    main()
